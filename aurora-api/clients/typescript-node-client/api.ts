import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class OK {
    msg: string;
}

export class Error {
    msg: string;
    /**
    * The error code
    */
    code: Error.CodeEnum;
}

export module Error {
    export enum CodeEnum { 
        INTERNAL = <any> 'INTERNAL',
        KP_SERVICE_ERROR = <any> 'KP_SERVICE_ERROR',
        WEATHER_SERVICE_ERROR = <any> 'WEATHER_SERVICE_ERROR',
        SUNSETRISE_SERVICE_ERROR = <any> 'SUNSETRISE_SERVICE_ERROR',
    }
}
export class Location {
    lat: number;
    lng: number;
}

export class GeomagnaticLocation {
    latG: number;
    lngG: number;
}

export class KpInformation {
    utc: number;
    date: Date;
    kpValue: number;
}

export class WeatherInformation {
    summary: string;
}

export class Rating {
    location: Location;
    locationGeomagnatic: GeomagnaticLocation;
    kp: KpInformation;
    weather: WeatherInformation;
}

export class Notification {
    playSound: boolean;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    applyToRequest(requestOptions: request.Options): void {
        // TODO: support oauth
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class KPIndexApi {
    private basePath = 'http://check-aurora-api.herokuapp.com';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public getKpIndex (uTCDateTime?: string) : Promise<{ response: http.ClientResponse; body: Array<KpInformation>;  }> {
        var path = this.url + this.basePath + '/kpIndex';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        if (uTCDateTime !== undefined) {
            queryParameters['UTCDateTime'] = uTCDateTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: Array<KpInformation>;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getLastKpIndex (uTCDateTime?: string) : Promise<{ response: http.ClientResponse; body: KpInformation;  }> {
        var path = this.url + this.basePath + '/kpIndex/last';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        if (uTCDateTime !== undefined) {
            queryParameters['UTCDateTime'] = uTCDateTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: KpInformation;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class NotifyApi {
    private basePath = 'http://check-aurora-api.herokuapp.com';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public createNotification (body: Notification) : Promise<{ response: http.ClientResponse; body: OK;  }> {
        var path = this.url + this.basePath + '/notification';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling createNotification');
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: OK;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public deleteNotification () : Promise<{ response: http.ClientResponse; body: OK;  }> {
        var path = this.url + this.basePath + '/notification';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: OK;  }>();

        var requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class LocationApi {
    private basePath = 'http://check-aurora-api.herokuapp.com';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public locationGet () : Promise<{ response: http.ClientResponse;  }> {
        var path = this.url + this.basePath + '/location';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public updateLocation (deviceId: string, deviceType: string, lat: number, lng: number) : Promise<{ response: http.ClientResponse;  }> {
        var path = this.url + this.basePath + '/location';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling updateLocation');
        }

        // verify required parameter 'deviceType' is set
        if (!deviceType) {
            throw new Error('Missing required parameter deviceType when calling updateLocation');
        }

        // verify required parameter 'lat' is set
        if (!lat) {
            throw new Error('Missing required parameter lat when calling updateLocation');
        }

        // verify required parameter 'lng' is set
        if (!lng) {
            throw new Error('Missing required parameter lng when calling updateLocation');
        }

        if (deviceId !== undefined) {
            queryParameters['deviceId'] = deviceId;
        }

        if (deviceType !== undefined) {
            queryParameters['deviceType'] = deviceType;
        }

        if (lat !== undefined) {
            queryParameters['lat'] = lat;
        }

        if (lng !== undefined) {
            queryParameters['lng'] = lng;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class RatingsApi {
    private basePath = 'http://check-aurora-api.herokuapp.com';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public getRating (lng: number, lat: number, uTCDateTime?: string) : Promise<{ response: http.ClientResponse; body: Array<Rating>;  }> {
        var path = this.url + this.basePath + '/ratings';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'lng' is set
        if (!lng) {
            throw new Error('Missing required parameter lng when calling getRating');
        }

        // verify required parameter 'lat' is set
        if (!lat) {
            throw new Error('Missing required parameter lat when calling getRating');
        }

        if (lng !== undefined) {
            queryParameters['lng'] = lng;
        }

        if (lat !== undefined) {
            queryParameters['lat'] = lat;
        }

        if (uTCDateTime !== undefined) {
            queryParameters['UTCDateTime'] = uTCDateTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: Array<Rating>;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
